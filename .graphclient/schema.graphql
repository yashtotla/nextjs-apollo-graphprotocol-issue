schema {
  query: Query
  subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

interface Action {
  id: String!
}

input Action_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Action_filter]
  or: [Action_filter]
}

enum Action_orderBy {
  id
}

type AllocatedCollateral {
  id: String!
  user: Bytes!
  strategyID: BigInt!
  basis: Bytes!
  amount: BigInt!
}

input AllocatedCollateral_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  user: Bytes
  user_not: Bytes
  user_gt: Bytes
  user_lt: Bytes
  user_gte: Bytes
  user_lte: Bytes
  user_in: [Bytes!]
  user_not_in: [Bytes!]
  user_contains: Bytes
  user_not_contains: Bytes
  strategyID: BigInt
  strategyID_not: BigInt
  strategyID_gt: BigInt
  strategyID_lt: BigInt
  strategyID_gte: BigInt
  strategyID_lte: BigInt
  strategyID_in: [BigInt!]
  strategyID_not_in: [BigInt!]
  basis: Bytes
  basis_not: Bytes
  basis_gt: Bytes
  basis_lt: Bytes
  basis_gte: Bytes
  basis_lte: Bytes
  basis_in: [Bytes!]
  basis_not_in: [Bytes!]
  basis_contains: Bytes
  basis_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AllocatedCollateral_filter]
  or: [AllocatedCollateral_filter]
}

enum AllocatedCollateral_orderBy {
  id
  user
  strategyID
  basis
  amount
}

type Annihilated implements Action {
  id: String!
}

input Annihilated_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Annihilated_filter]
  or: [Annihilated_filter]
}

enum Annihilated_orderBy {
  id
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

enum CallPut {
  C
  P
}

type CollateralLock {
  id: String!
  user: Bytes!
  locker: Bytes!
  basis: Bytes!
  expiry: BigInt!
  amount: BigInt!
}

input CollateralLock_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  user: Bytes
  user_not: Bytes
  user_gt: Bytes
  user_lt: Bytes
  user_gte: Bytes
  user_lte: Bytes
  user_in: [Bytes!]
  user_not_in: [Bytes!]
  user_contains: Bytes
  user_not_contains: Bytes
  locker: Bytes
  locker_not: Bytes
  locker_gt: Bytes
  locker_lt: Bytes
  locker_gte: Bytes
  locker_lte: Bytes
  locker_in: [Bytes!]
  locker_not_in: [Bytes!]
  locker_contains: Bytes
  locker_not_contains: Bytes
  basis: Bytes
  basis_not: Bytes
  basis_gt: Bytes
  basis_lt: Bytes
  basis_gte: Bytes
  basis_lte: Bytes
  basis_in: [Bytes!]
  basis_not_in: [Bytes!]
  basis_contains: Bytes
  basis_not_contains: Bytes
  expiry: BigInt
  expiry_not: BigInt
  expiry_gt: BigInt
  expiry_lt: BigInt
  expiry_gte: BigInt
  expiry_lte: BigInt
  expiry_in: [BigInt!]
  expiry_not_in: [BigInt!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [CollateralLock_filter]
  or: [CollateralLock_filter]
}

enum CollateralLock_orderBy {
  id
  user
  locker
  basis
  expiry
  amount
}

type Combined implements Action {
  id: String!
}

input Combined_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Combined_filter]
  or: [Combined_filter]
}

enum Combined_orderBy {
  id
}

enum Direction {
  LONG
  SHORT
}

type GlobalData {
  id: Bytes!
  owner: Bytes!
  liquidator: Bytes!
  collateralManager: Bytes!
  polaron: BigInt!
  proton: BigInt!
  electron: BigInt!
  neutron: BigInt!
}

type GlobalDataCM {
  id: Bytes!
  tfm: Bytes!
  collateralNonce: BigInt!
  treasury: Bytes!
  insuranceFund: Bytes!
  web2: Bytes!
  relay: Bytes!
}

input GlobalDataCM_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  tfm: Bytes
  tfm_not: Bytes
  tfm_gt: Bytes
  tfm_lt: Bytes
  tfm_gte: Bytes
  tfm_lte: Bytes
  tfm_in: [Bytes!]
  tfm_not_in: [Bytes!]
  tfm_contains: Bytes
  tfm_not_contains: Bytes
  collateralNonce: BigInt
  collateralNonce_not: BigInt
  collateralNonce_gt: BigInt
  collateralNonce_lt: BigInt
  collateralNonce_gte: BigInt
  collateralNonce_lte: BigInt
  collateralNonce_in: [BigInt!]
  collateralNonce_not_in: [BigInt!]
  treasury: Bytes
  treasury_not: Bytes
  treasury_gt: Bytes
  treasury_lt: Bytes
  treasury_gte: Bytes
  treasury_lte: Bytes
  treasury_in: [Bytes!]
  treasury_not_in: [Bytes!]
  treasury_contains: Bytes
  treasury_not_contains: Bytes
  insuranceFund: Bytes
  insuranceFund_not: Bytes
  insuranceFund_gt: Bytes
  insuranceFund_lt: Bytes
  insuranceFund_gte: Bytes
  insuranceFund_lte: Bytes
  insuranceFund_in: [Bytes!]
  insuranceFund_not_in: [Bytes!]
  insuranceFund_contains: Bytes
  insuranceFund_not_contains: Bytes
  web2: Bytes
  web2_not: Bytes
  web2_gt: Bytes
  web2_lt: Bytes
  web2_gte: Bytes
  web2_lte: Bytes
  web2_in: [Bytes!]
  web2_not_in: [Bytes!]
  web2_contains: Bytes
  web2_not_contains: Bytes
  relay: Bytes
  relay_not: Bytes
  relay_gt: Bytes
  relay_lt: Bytes
  relay_gte: Bytes
  relay_lte: Bytes
  relay_in: [Bytes!]
  relay_not_in: [Bytes!]
  relay_contains: Bytes
  relay_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [GlobalDataCM_filter]
  or: [GlobalDataCM_filter]
}

enum GlobalDataCM_orderBy {
  id
  tfm
  collateralNonce
  treasury
  insuranceFund
  web2
  relay
}

input GlobalData_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  owner: Bytes
  owner_not: Bytes
  owner_gt: Bytes
  owner_lt: Bytes
  owner_gte: Bytes
  owner_lte: Bytes
  owner_in: [Bytes!]
  owner_not_in: [Bytes!]
  owner_contains: Bytes
  owner_not_contains: Bytes
  liquidator: Bytes
  liquidator_not: Bytes
  liquidator_gt: Bytes
  liquidator_lt: Bytes
  liquidator_gte: Bytes
  liquidator_lte: Bytes
  liquidator_in: [Bytes!]
  liquidator_not_in: [Bytes!]
  liquidator_contains: Bytes
  liquidator_not_contains: Bytes
  collateralManager: Bytes
  collateralManager_not: Bytes
  collateralManager_gt: Bytes
  collateralManager_lt: Bytes
  collateralManager_gte: Bytes
  collateralManager_lte: Bytes
  collateralManager_in: [Bytes!]
  collateralManager_not_in: [Bytes!]
  collateralManager_contains: Bytes
  collateralManager_not_contains: Bytes
  polaron: BigInt
  polaron_not: BigInt
  polaron_gt: BigInt
  polaron_lt: BigInt
  polaron_gte: BigInt
  polaron_lte: BigInt
  polaron_in: [BigInt!]
  polaron_not_in: [BigInt!]
  proton: BigInt
  proton_not: BigInt
  proton_gt: BigInt
  proton_lt: BigInt
  proton_gte: BigInt
  proton_lte: BigInt
  proton_in: [BigInt!]
  proton_not_in: [BigInt!]
  electron: BigInt
  electron_not: BigInt
  electron_gt: BigInt
  electron_lt: BigInt
  electron_gte: BigInt
  electron_lte: BigInt
  electron_in: [BigInt!]
  electron_not_in: [BigInt!]
  neutron: BigInt
  neutron_not: BigInt
  neutron_gt: BigInt
  neutron_lt: BigInt
  neutron_gte: BigInt
  neutron_lte: BigInt
  neutron_in: [BigInt!]
  neutron_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [GlobalData_filter]
  or: [GlobalData_filter]
}

enum GlobalData_orderBy {
  id
  owner
  liquidator
  collateralManager
  polaron
  proton
  electron
  neutron
}

type Liquidated implements Action {
  id: String!
}

input Liquidated_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Liquidated_filter]
  or: [Liquidated_filter]
}

enum Liquidated_orderBy {
  id
}

type Novated implements Action {
  id: String!
}

input Novated_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Novated_filter]
  or: [Novated_filter]
}

enum Novated_orderBy {
  id
}

type Option {
  id: String!
  direction: Direction!
  notional: BigInt!
  bra: Bytes!
  ket: Bytes!
  expiry: BigInt!
  strike: BigInt!
  callput: CallPut!
}

input Option_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  direction: Direction
  direction_not: Direction
  direction_in: [Direction!]
  direction_not_in: [Direction!]
  notional: BigInt
  notional_not: BigInt
  notional_gt: BigInt
  notional_lt: BigInt
  notional_gte: BigInt
  notional_lte: BigInt
  notional_in: [BigInt!]
  notional_not_in: [BigInt!]
  bra: Bytes
  bra_not: Bytes
  bra_gt: Bytes
  bra_lt: Bytes
  bra_gte: Bytes
  bra_lte: Bytes
  bra_in: [Bytes!]
  bra_not_in: [Bytes!]
  bra_contains: Bytes
  bra_not_contains: Bytes
  ket: Bytes
  ket_not: Bytes
  ket_gt: Bytes
  ket_lt: Bytes
  ket_gte: Bytes
  ket_lte: Bytes
  ket_in: [Bytes!]
  ket_not_in: [Bytes!]
  ket_contains: Bytes
  ket_not_contains: Bytes
  expiry: BigInt
  expiry_not: BigInt
  expiry_gt: BigInt
  expiry_lt: BigInt
  expiry_gte: BigInt
  expiry_lte: BigInt
  expiry_in: [BigInt!]
  expiry_not_in: [BigInt!]
  strike: BigInt
  strike_not: BigInt
  strike_gt: BigInt
  strike_lt: BigInt
  strike_gte: BigInt
  strike_lte: BigInt
  strike_in: [BigInt!]
  strike_not_in: [BigInt!]
  callput: CallPut
  callput_not: CallPut
  callput_in: [CallPut!]
  callput_not_in: [CallPut!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Option_filter]
  or: [Option_filter]
}

enum Option_orderBy {
  id
  direction
  notional
  bra
  ket
  expiry
  strike
  callput
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Photon {
  id: Bytes!
  mass: BigInt!
}

input Photon_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  mass: BigInt
  mass_not: BigInt
  mass_gt: BigInt
  mass_lt: BigInt
  mass_gte: BigInt
  mass_lte: BigInt
  mass_in: [BigInt!]
  mass_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Photon_filter]
  or: [Photon_filter]
}

enum Photon_orderBy {
  id
  mass
}

type Query {
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  photon(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Photon
  photons(
    skip: Int = 0
    first: Int = 100
    orderBy: Photon_orderBy
    orderDirection: OrderDirection
    where: Photon_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Photon!]!
  allocatedCollateral(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AllocatedCollateral
  allocatedCollaterals(
    skip: Int = 0
    first: Int = 100
    orderBy: AllocatedCollateral_orderBy
    orderDirection: OrderDirection
    where: AllocatedCollateral_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AllocatedCollateral!]!
  unallocatedCollateral(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UnallocatedCollateral
  unallocatedCollaterals(
    skip: Int = 0
    first: Int = 100
    orderBy: UnallocatedCollateral_orderBy
    orderDirection: OrderDirection
    where: UnallocatedCollateral_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UnallocatedCollateral!]!
  globalData(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GlobalData
  globalDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: GlobalData_orderBy
    orderDirection: OrderDirection
    where: GlobalData_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [GlobalData!]!
  globalDataCM(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GlobalDataCM
  globalDataCMs(
    skip: Int = 0
    first: Int = 100
    orderBy: GlobalDataCM_orderBy
    orderDirection: OrderDirection
    where: GlobalDataCM_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [GlobalDataCM!]!
  strategy(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Strategy
  strategies(
    skip: Int = 0
    first: Int = 100
    orderBy: Strategy_orderBy
    orderDirection: OrderDirection
    where: Strategy_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Strategy!]!
  option(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Option
  options(
    skip: Int = 0
    first: Int = 100
    orderBy: Option_orderBy
    orderDirection: OrderDirection
    where: Option_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Option!]!
  trustedLocker(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TrustedLocker
  trustedLockers(
    skip: Int = 0
    first: Int = 100
    orderBy: TrustedLocker_orderBy
    orderDirection: OrderDirection
    where: TrustedLocker_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TrustedLocker!]!
  collateralLock(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CollateralLock
  collateralLocks(
    skip: Int = 0
    first: Int = 100
    orderBy: CollateralLock_orderBy
    orderDirection: OrderDirection
    where: CollateralLock_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CollateralLock!]!
  liquidated(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Liquidated
  liquidateds(
    skip: Int = 0
    first: Int = 100
    orderBy: Liquidated_orderBy
    orderDirection: OrderDirection
    where: Liquidated_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Liquidated!]!
  transferred(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transferred
  transferreds(
    skip: Int = 0
    first: Int = 100
    orderBy: Transferred_orderBy
    orderDirection: OrderDirection
    where: Transferred_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transferred!]!
  combined(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Combined
  combineds(
    skip: Int = 0
    first: Int = 100
    orderBy: Combined_orderBy
    orderDirection: OrderDirection
    where: Combined_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Combined!]!
  novated(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Novated
  novateds(
    skip: Int = 0
    first: Int = 100
    orderBy: Novated_orderBy
    orderDirection: OrderDirection
    where: Novated_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Novated!]!
  annihilated(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Annihilated
  annihilateds(
    skip: Int = 0
    first: Int = 100
    orderBy: Annihilated_orderBy
    orderDirection: OrderDirection
    where: Annihilated_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Annihilated!]!
  action(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Action
  actions(
    skip: Int = 0
    first: Int = 100
    orderBy: Action_orderBy
    orderDirection: OrderDirection
    where: Action_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Action!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Strategy {
  id: String!
  transferable: Boolean!
  bra: Bytes!
  ket: Bytes!
  basis: Bytes!
  alpha: Bytes!
  omega: Bytes!
  expiry: BigInt!
  wavefn(skip: Int = 0, first: Int = 100, orderBy: Option_orderBy, orderDirection: OrderDirection, where: Option_filter): [Option!]
  deleted: Boolean!
}

input Strategy_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  transferable: Boolean
  transferable_not: Boolean
  transferable_in: [Boolean!]
  transferable_not_in: [Boolean!]
  bra: Bytes
  bra_not: Bytes
  bra_gt: Bytes
  bra_lt: Bytes
  bra_gte: Bytes
  bra_lte: Bytes
  bra_in: [Bytes!]
  bra_not_in: [Bytes!]
  bra_contains: Bytes
  bra_not_contains: Bytes
  ket: Bytes
  ket_not: Bytes
  ket_gt: Bytes
  ket_lt: Bytes
  ket_gte: Bytes
  ket_lte: Bytes
  ket_in: [Bytes!]
  ket_not_in: [Bytes!]
  ket_contains: Bytes
  ket_not_contains: Bytes
  basis: Bytes
  basis_not: Bytes
  basis_gt: Bytes
  basis_lt: Bytes
  basis_gte: Bytes
  basis_lte: Bytes
  basis_in: [Bytes!]
  basis_not_in: [Bytes!]
  basis_contains: Bytes
  basis_not_contains: Bytes
  alpha: Bytes
  alpha_not: Bytes
  alpha_gt: Bytes
  alpha_lt: Bytes
  alpha_gte: Bytes
  alpha_lte: Bytes
  alpha_in: [Bytes!]
  alpha_not_in: [Bytes!]
  alpha_contains: Bytes
  alpha_not_contains: Bytes
  omega: Bytes
  omega_not: Bytes
  omega_gt: Bytes
  omega_lt: Bytes
  omega_gte: Bytes
  omega_lte: Bytes
  omega_in: [Bytes!]
  omega_not_in: [Bytes!]
  omega_contains: Bytes
  omega_not_contains: Bytes
  expiry: BigInt
  expiry_not: BigInt
  expiry_gt: BigInt
  expiry_lt: BigInt
  expiry_gte: BigInt
  expiry_lte: BigInt
  expiry_in: [BigInt!]
  expiry_not_in: [BigInt!]
  wavefn: [String!]
  wavefn_not: [String!]
  wavefn_contains: [String!]
  wavefn_contains_nocase: [String!]
  wavefn_not_contains: [String!]
  wavefn_not_contains_nocase: [String!]
  wavefn_: Option_filter
  deleted: Boolean
  deleted_not: Boolean
  deleted_in: [Boolean!]
  deleted_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Strategy_filter]
  or: [Strategy_filter]
}

enum Strategy_orderBy {
  id
  transferable
  bra
  ket
  basis
  alpha
  omega
  expiry
  wavefn
  deleted
}

type Subscription {
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  photon(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Photon
  photons(
    skip: Int = 0
    first: Int = 100
    orderBy: Photon_orderBy
    orderDirection: OrderDirection
    where: Photon_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Photon!]!
  allocatedCollateral(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AllocatedCollateral
  allocatedCollaterals(
    skip: Int = 0
    first: Int = 100
    orderBy: AllocatedCollateral_orderBy
    orderDirection: OrderDirection
    where: AllocatedCollateral_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AllocatedCollateral!]!
  unallocatedCollateral(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UnallocatedCollateral
  unallocatedCollaterals(
    skip: Int = 0
    first: Int = 100
    orderBy: UnallocatedCollateral_orderBy
    orderDirection: OrderDirection
    where: UnallocatedCollateral_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UnallocatedCollateral!]!
  globalData(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GlobalData
  globalDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: GlobalData_orderBy
    orderDirection: OrderDirection
    where: GlobalData_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [GlobalData!]!
  globalDataCM(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GlobalDataCM
  globalDataCMs(
    skip: Int = 0
    first: Int = 100
    orderBy: GlobalDataCM_orderBy
    orderDirection: OrderDirection
    where: GlobalDataCM_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [GlobalDataCM!]!
  strategy(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Strategy
  strategies(
    skip: Int = 0
    first: Int = 100
    orderBy: Strategy_orderBy
    orderDirection: OrderDirection
    where: Strategy_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Strategy!]!
  option(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Option
  options(
    skip: Int = 0
    first: Int = 100
    orderBy: Option_orderBy
    orderDirection: OrderDirection
    where: Option_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Option!]!
  trustedLocker(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TrustedLocker
  trustedLockers(
    skip: Int = 0
    first: Int = 100
    orderBy: TrustedLocker_orderBy
    orderDirection: OrderDirection
    where: TrustedLocker_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TrustedLocker!]!
  collateralLock(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CollateralLock
  collateralLocks(
    skip: Int = 0
    first: Int = 100
    orderBy: CollateralLock_orderBy
    orderDirection: OrderDirection
    where: CollateralLock_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CollateralLock!]!
  liquidated(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Liquidated
  liquidateds(
    skip: Int = 0
    first: Int = 100
    orderBy: Liquidated_orderBy
    orderDirection: OrderDirection
    where: Liquidated_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Liquidated!]!
  transferred(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transferred
  transferreds(
    skip: Int = 0
    first: Int = 100
    orderBy: Transferred_orderBy
    orderDirection: OrderDirection
    where: Transferred_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transferred!]!
  combined(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Combined
  combineds(
    skip: Int = 0
    first: Int = 100
    orderBy: Combined_orderBy
    orderDirection: OrderDirection
    where: Combined_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Combined!]!
  novated(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Novated
  novateds(
    skip: Int = 0
    first: Int = 100
    orderBy: Novated_orderBy
    orderDirection: OrderDirection
    where: Novated_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Novated!]!
  annihilated(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Annihilated
  annihilateds(
    skip: Int = 0
    first: Int = 100
    orderBy: Annihilated_orderBy
    orderDirection: OrderDirection
    where: Annihilated_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Annihilated!]!
  action(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Action
  actions(
    skip: Int = 0
    first: Int = 100
    orderBy: Action_orderBy
    orderDirection: OrderDirection
    where: Action_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Action!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Token {
  id: Bytes!
  name: String!
  symbol: String!
  decimals: BigInt!
}

input Token_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  decimals: BigInt
  decimals_not: BigInt
  decimals_gt: BigInt
  decimals_lt: BigInt
  decimals_gte: BigInt
  decimals_lte: BigInt
  decimals_in: [BigInt!]
  decimals_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Token_filter]
  or: [Token_filter]
}

enum Token_orderBy {
  id
  name
  symbol
  decimals
}

type Transferred implements Action {
  id: String!
}

input Transferred_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Transferred_filter]
  or: [Transferred_filter]
}

enum Transferred_orderBy {
  id
}

type TrustedLocker {
  id: String!
  user: Bytes!
  locker: Bytes!
  trusted: Boolean!
}

input TrustedLocker_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  user: Bytes
  user_not: Bytes
  user_gt: Bytes
  user_lt: Bytes
  user_gte: Bytes
  user_lte: Bytes
  user_in: [Bytes!]
  user_not_in: [Bytes!]
  user_contains: Bytes
  user_not_contains: Bytes
  locker: Bytes
  locker_not: Bytes
  locker_gt: Bytes
  locker_lt: Bytes
  locker_gte: Bytes
  locker_lte: Bytes
  locker_in: [Bytes!]
  locker_not_in: [Bytes!]
  locker_contains: Bytes
  locker_not_contains: Bytes
  trusted: Boolean
  trusted_not: Boolean
  trusted_in: [Boolean!]
  trusted_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TrustedLocker_filter]
  or: [TrustedLocker_filter]
}

enum TrustedLocker_orderBy {
  id
  user
  locker
  trusted
}

type UnallocatedCollateral {
  id: String!
  user: Bytes!
  basis: Bytes!
  amount: BigInt!
}

input UnallocatedCollateral_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  user: Bytes
  user_not: Bytes
  user_gt: Bytes
  user_lt: Bytes
  user_gte: Bytes
  user_lte: Bytes
  user_in: [Bytes!]
  user_not_in: [Bytes!]
  user_contains: Bytes
  user_not_contains: Bytes
  basis: Bytes
  basis_not: Bytes
  basis_gt: Bytes
  basis_lt: Bytes
  basis_gte: Bytes
  basis_lte: Bytes
  basis_in: [Bytes!]
  basis_not_in: [Bytes!]
  basis_contains: Bytes
  basis_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [UnallocatedCollateral_filter]
  or: [UnallocatedCollateral_filter]
}

enum UnallocatedCollateral_orderBy {
  id
  user
  basis
  amount
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}